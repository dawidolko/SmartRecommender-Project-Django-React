@startuml Association_Rules_Activity
!theme plain

start

partition "Frontend - CartContent.jsx" {
  :Klient dodaje produkty do koszyka;
  :useEffect wykrywa zmiany w items;
  :fetchRecommendations();
  :GET /api/frequently-bought-together/;
}

partition "Backend - association_views.py" {
  :FrequentlyBoughtTogetherAPI.get();
  :Pobierz cart_product_ids[];
  :ProductAssociation.objects.filter();
  :Zwróć top 5 rekomendacji;
}

:Wyświetl "Frequently Bought Together";

note right
  Wyświetla confidence %, 
  lift, product details
end note

:Klient może dodać rekomendowany produkt;

if (Klient finalizuje zamówienie?) then (TAK)
  
  partition "Django Signals - signals.py" {
    :@receiver(post_save, sender=Order);
    :handle_new_order_and_analytics();
    :transaction.on_commit();
    :run_all_analytics_after_order();
  }

  partition "Association Rules Generation" {
    :generate_association_rules_after_order();
    :Pobierz ostatnie 1000 zamówień;
    :Order.objects.prefetch_related();
    
    :Utwórz transactions[];
    note right
      transactions = [
        ["product_1", "product_2"],
        ["product_1", "product_3", "product_4"]
      ]
    end note
    
    if (len(transactions) >= 2?) then (TAK)
      :CustomAssociationRules(min_support=0.01);
      :generate_association_rules();
      
      partition "Apriori Algorithm Implementation" {
        :_find_frequent_itemsets_with_bitmap(transactions);
        
        note right
          Wzór: Support(X) = count(X) / |transactions|
          Źródło: Agrawal & Srikant (1994)
        end note
        
        :Krok 1: item_counts = defaultdict(int);
        :Zlicz pojedyncze produkty (1-itemsets);
        :min_count_threshold = min_support * total;
        
        :Krok 2: Filtruj przez min_support;
        :frequent_items = {} (early pruning);
        
        :Krok 3: Twórz bitmapy;
        :item_to_id mapping;
        :transaction_bitmaps = [];
        
        note right
          Bitmap optimization:
          bitmap |= (1 << item_to_id[item])
          Źródło: Zaki (2000)
        end note
        
        :Krok 4: _generate_2_itemsets_with_bitmap();
        
        :Iteruj pary (i, j) gdzie i < j;
        :pair_bitmap = item1_bit | item2_bit;
        :count = sum(1 for tb if (tb & pair_bitmap) == pair_bitmap);
        
        if (count >= min_count_threshold?) then (TAK)
          :support = count / total_transactions;
          :frequent_2_itemsets[pair] = support;
        endif
      }
      
      partition "Rules Generation" {
        :_generate_optimized_rules_from_itemsets(frequent_itemsets, transactions);
        
        :Krok 1: Twórz cache dla pojedynczych itemów;
        :item_support_cache = {};
        :for itemset if len(itemset) == 1;
        
        :Krok 2: Dla każdej pary (2-itemsets);
        :support_1 = item_support_cache.get(item1, 0);
        :support_2 = item_support_cache.get(item2, 0);
        
        note right
          Wzory (Agrawal & Srikant 1994):
          Confidence(A→B) = Support(A,B) / Support(A)
          Lift(A→B) = Support(A,B) / (Support(A) × Support(B))
        end note
        
        if (support_1 > 0?) then (TAK)
          :confidence_1_to_2 = support / support_1;
        else (NIE)
          :confidence_1_to_2 = 0;
        endif
        
        if (support_2 > 0?) then (TAK)
          :confidence_2_to_1 = support / support_2;
        else (NIE)
          :confidence_2_to_1 = 0;
        endif
        
        if ((support_1 * support_2) > 0?) then (TAK)
          :lift = support / (support_1 * support_2);
        else (NIE)
          :lift = 0;
        endif
        
        if (confidence_1_to_2 >= min_confidence?) then (TAK)
          :rules.append({item1→item2, support, confidence, lift});
        endif
        
        if (confidence_2_to_1 >= min_confidence?) then (TAK)
          :rules.append({item2→item1, support, confidence, lift});
        endif
      }
      
      :Sortuj rules według (lift, confidence);
      :ProductAssociation.objects.all().delete();
      :bulk_create(associations_to_create);
      :Cache invalidation (association_rules_list);
      
      note right
        Zapisuje do 500 
        najlepszych reguł
      end note
      
    else (NIE)
      :Brak wystarczających transakcji;
    endif
  }
  
else (NIE)
  :Kontynuuj przeglądanie;
endif

partition "Admin Panel - AdminStatistics.jsx" {
  if (Admin klika "Update Rules"?) then (TAK)
    :updateAssociationRules();
    :POST /api/update-association-rules/;
    :UpdateAssociationRulesAPI.post();
    :Manualne przeliczenie reguł;
    :toast.success() notification;
  endif
  
  :fetchAssociationRules();
  :GET /api/association-rules/;
  :AssociationRulesListAPI.get();
  :Wyświetl tabelę z metrykami;
}

stop
@enduml