@startuml Association_Rules_Sequence
!theme plain

actor "Klient" as C
participant "CartContent.jsx" as Cart
participant "FrequentlyBoughtTogetherAPI" as API1
participant "ProductAssociation Model" as PA
participant "Django Signals" as Signals
participant "CustomAssociationRules" as CAR
participant "AdminStatistics.jsx" as Admin
participant "UpdateAssociationRulesAPI" as API2

== Przeglądanie Rekomendacji ==

C -> Cart: Dodaje produkty do koszyka
activate Cart

Cart -> Cart: useEffect wykrywa zmiany w items
Cart -> API1: GET /api/frequently-bought-together/?product_ids[]=1&product_ids[]=2
activate API1

API1 -> PA: ProductAssociation.objects.filter(product_1_id__in=product_ids)
activate PA
PA --> API1: QuerySet z regułami asocjacji
deactivate PA

API1 -> API1: order_by("-lift", "-confidence")[:5]
API1 --> Cart: Response z top 5 rekomendacjami
deactivate API1

Cart -> Cart: Renderuj "Frequently Bought Together"
Cart --> C: Wyświetla rekomendacje z confidence %
deactivate Cart

== Automatyczne Generowanie Reguł ==

C -> C: Finalizuje zamówienie
C -> Signals: Order.save() triggers @receiver(post_save)
activate Signals

Signals -> Signals: handle_new_order_and_analytics()
Signals -> Signals: transaction.on_commit()
Signals -> Signals: run_all_analytics_after_order()
Signals -> Signals: generate_association_rules_after_order()

Signals -> PA: Order.objects.prefetch_related()[:1000]
activate PA
PA --> Signals: Ostatnie 1000 zamówień
deactivate PA

Signals -> Signals: Buduj transactions[] z OrderProduct

Signals -> CAR: CustomAssociationRules(min_support=0.01, min_confidence=0.1)
activate CAR

CAR -> CAR: generate_association_rules(transactions)
CAR -> CAR: _find_frequent_itemsets_with_bitmap(transactions)

note right of CAR
  **Krok 1-2: Zlicz i filtruj pojedyncze produkty**
  item_counts = defaultdict(int)
  for transaction in transactions:
    for item in transaction:
      item_counts[item] += 1
  
  min_count_threshold = min_support * total
  frequent_items = {item: support 
    if count >= min_count_threshold}
  
  **Wzór:** Support(X) = count(X) / |transactions|
  **Źródło:** Agrawal & Srikant (1994)
end note

CAR -> CAR: **Krok 3:** Twórz bitmapy dla transakcji
CAR -> CAR: item_to_id = {item: idx}
CAR -> CAR: transaction_bitmaps = []

note right of CAR
  **Optymalizacja bitmap (Zaki 2000):**
  for transaction in transactions:
    bitmap = 0
    for item in transaction:
      if item in item_to_id:
        bitmap |= (1 << item_to_id[item])
    transaction_bitmaps.append(bitmap)
end note

CAR -> CAR: **Krok 4:** _generate_2_itemsets_with_bitmap()

loop Dla każdej pary (i, j) where i < j
  CAR -> CAR: item1_bit = 1 << item_to_id[item1]
  CAR -> CAR: item2_bit = 1 << item_to_id[item2]
  CAR -> CAR: pair_bitmap = item1_bit | item2_bit
  
  CAR -> CAR: count = sum(1 for tb in transaction_bitmaps\nif (tb & pair_bitmap) == pair_bitmap)
  
  alt count >= min_count_threshold
    CAR -> CAR: support = count / total_transactions
    CAR -> CAR: frequent_2_itemsets[pair] = support
  end
end

CAR -> CAR: _generate_optimized_rules_from_itemsets(frequent_itemsets, transactions)

CAR -> CAR: **Krok 1:** Twórz item_support_cache
loop Dla itemset if len(itemset) == 1
  CAR -> CAR: item_support_cache[item] = support
end

CAR -> CAR: **Krok 2:** Generuj reguły dla par

loop Dla każdej pary (item1, item2) in frequent_itemsets
  CAR -> CAR: support_1 = item_support_cache.get(item1, 0)
  CAR -> CAR: support_2 = item_support_cache.get(item2, 0)
  
  note right of CAR
    **Wzory (Agrawal & Srikant 1994):**
    Confidence(A→B) = Support(A,B) / Support(A)
    Lift(A→B) = Support(A,B) / (Support(A) × Support(B))
    
    **Źródło dla Lift:** Brin, Motwani, Silverstein (1997)
  end note
  
  alt support_1 > 0
    CAR -> CAR: confidence_1_to_2 = support / support_1
  else
    CAR -> CAR: confidence_1_to_2 = 0
  end
  
  alt support_2 > 0
    CAR -> CAR: confidence_2_to_1 = support / support_2
  else
    CAR -> CAR: confidence_2_to_1 = 0
  end
  
  alt (support_1 * support_2) > 0
    CAR -> CAR: lift = support / (support_1 * support_2)
  else
    CAR -> CAR: lift = 0
  end
  
  alt confidence_1_to_2 >= min_confidence
    CAR -> CAR: rules.append({item1→item2, support, confidence_1_to_2, lift})
  end
  
  alt confidence_2_to_1 >= min_confidence
    CAR -> CAR: rules.append({item2→item1, support, confidence_2_to_1, lift})
  end
end

CAR -> CAR: rules.sort(key=lambda: (lift, confidence), reverse=True)

CAR --> Signals: Lista reguł z metrykami
deactivate CAR

Signals -> PA: ProductAssociation.objects.all().delete()
activate PA
Signals -> PA: bulk_create(associations_to_create[:500])
PA --> Signals: Utworzono reguły w bazie
deactivate PA

Signals -> Signals: cache.delete("association_rules_list")
Signals --> C: Reguły zaktualizowane
deactivate Signals

== Admin - Manualne Zarządzanie ==

Admin -> Admin: Otwiera panel administracyjny
activate Admin

Admin -> API2: GET /api/association-rules/
activate API2

API2 -> PA: ProductAssociation.objects.select_related()[:20]
activate PA
PA --> API2: Top 20 reguł z produktami
deactivate PA

API2 --> Admin: Serializowane reguły z metrykami
deactivate API2

Admin -> Admin: Renderuj tabelę (Support %, Confidence %, Lift)

alt Admin klika "Update Rules"
  Admin -> API2: POST /api/update-association-rules/
  activate API2
  
  API2 -> PA: ProductAssociation.objects.all().delete()
  activate PA
  deactivate PA
  
  API2 -> CAR: Uruchom ponownie algorytm Apriori
  activate CAR
  CAR --> API2: Nowe reguły
  deactivate CAR
  
  API2 -> PA: bulk_create(new_associations)
  activate PA
  deactivate PA
  
  API2 --> Admin: Success response z liczbą nowych reguł
  deactivate API2
  
  Admin -> Admin: toast.success("Rules updated!")
end

deactivate Admin

@enduml